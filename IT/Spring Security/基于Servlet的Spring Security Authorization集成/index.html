<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>基于Servlet的Spring Security Authorization集成 | 静石随笔</title><meta name="author" content="Dickens Hu"><meta name="copyright" content="Dickens Hu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="参考 Http Request权限认证Spring Security允许开发者在request级别对授权进行建模。例如，使用Spring Security，可以实现&#x2F;admin下的所有页面都需要一个权限，而所有其他页面只需要身份验证。 默认情况下，Spring Security要求对每个请求进行身份验证。也就是说，任何时候使用HttpSecurity实例时，都有必要声明自定义的授权规则。 当使用H">
<meta property="og:type" content="article">
<meta property="og:title" content="基于Servlet的Spring Security Authorization集成">
<meta property="og:url" content="http://silentstone.cn/IT/Spring%20Security/%E5%9F%BA%E4%BA%8EServlet%E7%9A%84Spring%20Security%20Authorization%E9%9B%86%E6%88%90/index.html">
<meta property="og:site_name" content="静石随笔">
<meta property="og:description" content="参考 Http Request权限认证Spring Security允许开发者在request级别对授权进行建模。例如，使用Spring Security，可以实现&#x2F;admin下的所有页面都需要一个权限，而所有其他页面只需要身份验证。 默认情况下，Spring Security要求对每个请求进行身份验证。也就是说，任何时候使用HttpSecurity实例时，都有必要声明自定义的授权规则。 当使用H">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://silentstone.cn/img/avatar.jpg">
<meta property="article:published_time" content="2023-06-29T08:29:25.000Z">
<meta property="article:modified_time" content="2023-06-30T01:47:31.597Z">
<meta property="article:author" content="Dickens Hu">
<meta property="article:tag" content="IT 随笔 博客 静石">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://silentstone.cn/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://silentstone.cn/IT/Spring%20Security/%E5%9F%BA%E4%BA%8EServlet%E7%9A%84Spring%20Security%20Authorization%E9%9B%86%E6%88%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基于Servlet的Spring Security Authorization集成',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-30 09:47:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 随笔系列</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="静石随笔"><span class="site-name">静石随笔</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 随笔系列</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">基于Servlet的Spring Security Authorization集成</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-29T08:29:25.000Z" title="发表于 2023-06-29 16:29:25">2023-06-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-30T01:47:31.597Z" title="更新于 2023-06-30 09:47:31">2023-06-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="基于Servlet的Spring Security Authorization集成"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/reference/servlet/authorization/index.html">参考</a></p>
<h1 id="Http-Request权限认证"><a href="#Http-Request权限认证" class="headerlink" title="Http Request权限认证"></a>Http Request权限认证</h1><p>Spring Security允许开发者在request级别对授权进行建模。<br>例如，使用Spring Security，可以实现<code>/admin</code>下的所有页面都需要一个<em>权限</em>，而所有其他页面只需要<em>身份验证</em>。</p>
<p>默认情况下，Spring Security要求对每个请求进行身份验证。也就是说，任何时候使用HttpSecurity实例时，都有必要声明自定义的授权规则。</p>
<p>当使用HttpSecurity实例时，至少应该设定:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">    .authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>这告诉Spring Security，应用程序中的任何端点都至少需要对安全上下文进行<em>身份验证</em>才能允许访问。</p>
<h2 id="请求授权组件工作原理"><a href="#请求授权组件工作原理" class="headerlink" title="请求授权组件工作原理"></a>请求授权组件工作原理</h2><p><img src="/img/IT/SpringSecurity/%E5%9F%BA%E4%BA%8EServlet%E7%9A%84Spring-Security-Authorization%E9%9B%86%E6%88%90-1.png" alt="Http Request权限认证"></p>
<ol>
<li>首先，<code>AuthorizationFilter</code>构造一个<code>Supplier</code>，该<code>Supplier</code>从<code>SecurityContexHolder</code>中检索一个<code>Authentication</code>。</li>
<li>其次，它将<code>Supplier&lt;Authentication&gt;</code>和<code>HttpServletRequest</code>传递给<code>AuthorizationManager</code>。<code>AuthorizationManager</code>将请求与<code>authorizeHttpRequests</code>中的模式匹配，并执行相应的规则。</li>
<li>如果拒绝授权，则生成<code>AuthorizationDeniedEvent</code>，并抛出<code>AccessDeniedException</code>。在这种情况下，<code>ExceptionTranslationFilter</code>处理<code>AccessDeniedException</code>。</li>
<li>如果授予访问权限，则生成<code>AuthorizationGrantedEvent</code>, <code>AuthorizationFilter</code>继续执行<code>FilterChain</code>，允许应用程序正常处理。</li>
</ol>
<h3 id="AuthorizationFilter默认是最后一个"><a href="#AuthorizationFilter默认是最后一个" class="headerlink" title="AuthorizationFilter默认是最后一个"></a>AuthorizationFilter默认是最后一个</h3><p>默认情况下，<code>AuthorizationFilter</code>位于<em>Spring Security过滤器链</em>的最后一个。<br>这意味着Spring Security的<em>身份验证过滤器</em>、<em>漏洞利用保护</em>和集成的其他过滤器<strong>不需要授权</strong>。如果在<code>AuthorizationFilter</code>之前添加自己的过滤器，它们也不需要授权;否则，需要授权。</p>
<p>当添加Spring MVC端点时，这通常变得很重要。因为它们是由DispatcherServlet执行的，而这是在AuthorizationFilter之后，所以端点需要包含在authorizeHttpRequests中才能被允许。</p>
<h3 id="所有Dispatche都是授权的"><a href="#所有Dispatche都是授权的" class="headerlink" title="所有Dispatche都是授权的"></a>所有Dispatche都是授权的</h3><p><code>AuthorizationFilter</code>不仅在每个请求上执行，而且在每个dispatch上执行。<br>这意味着REQUEST dispatch需要授权，<code>forward</code>、<code>ERROR</code>和<code>INCLUDE</code>也一样。</p>
<p>例如，Spring MVC可以将请求转发(FORWARD)给渲染thymleaf模板的视图解析器，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/endpoint&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">endpoint</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;endpoint&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，授权执行了两次:</p>
<ul>
<li>一次用于授权<code>/endpoint</code></li>
<li>一次用于转发给Thymeleaf以呈现“endpoint”模板。<br>出于这个原因，开发者可能希望<strong>允许所有FORWARD dispatch</strong>。</li>
</ul>
<p>这个原则的另一个例子是Spring Boot如何处理错误。如果容器捕获到异常，举例如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/endpoint&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">endpoint</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;unsupported&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后Boot将它分派给ERROR dispatch。<br>在这种情况下，授权也会发生两次:</p>
<ul>
<li>一次用于授权<code>/endpoint</code>，</li>
<li>一次用于dispatch错误。<br>出于这个原因，开发者可能希望<strong>允许所有的ERROR分派</strong>。</li>
</ul>
<h3 id="Authencation查找是延迟的"><a href="#Authencation查找是延迟的" class="headerlink" title="Authencation查找是延迟的"></a>Authencation查找是延迟的</h3><p>记住，<code>AuthorizationManager</code> API使用了一个<code>Supplier&lt;Authentication&gt;</code>。<br>当请求 <em>总是被允许</em> 或 <em>总是被拒绝</em> 时，这对<code>authorizehttprequest</code>很重要。在这些情况下，<strong>不会</strong>查询Authentication，从而让请求更快。</p>
<h2 id="授权端点"><a href="#授权端点" class="headerlink" title="授权端点"></a>授权端点</h2><p>开发者可以通过按优先顺序添加更多规则来配置Spring Security，使其具有不同的规则。</p>
<p>如果想要求<code>/endpoint</code>只能由具有<code>USER</code>权限的终端用户访问，那么可以这样做:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">SecurityFilterChain <span class="title function_">web</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	http</span><br><span class="line">		.authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">			.requestMatchers(<span class="string">&quot;/endpoint&quot;</span>).hasAuthority(<span class="string">&#x27;USER&#x27;</span>)</span><br><span class="line">			.anyRequest().authenticated()</span><br><span class="line">		)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，可以将声明分解为模式&#x2F;规则对。<br><code>AuthorizationFilter</code>按照列表的顺序处理这些配置对，<strong>仅将第一个匹配应用于请求</strong>。这意味着即使<code>/**</code>也会匹配<code>/endpoint</code>，上述规则也不是问题。上述规则可以理解为“如果请求是<code>/endpoint</code>，那么需要<code>USER</code>权限;否则，只需要身份验证”。<br>Spring Security支持多种模式和规则;开发者还可以通过编程方式创建开发者自己模式和规则。</p>
<p>一旦获得授权，开发者可以使用<em>Security的测试支持</em>以以下方式进行测试:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WithMockUser(authorities=&quot;USER&quot;)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">endpointWhenUserAuthorityThenAuthorized</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mvc.perform(get(<span class="string">&quot;/endpoint&quot;</span>))</span><br><span class="line">        .andExpect(status().isOk());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WithMockUser</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">endpointWhenNotUserAuthorityThenForbidden</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mvc.perform(get(<span class="string">&quot;/endpoint&quot;</span>))</span><br><span class="line">        .andExpect(status().isForbidden());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">anyWhenUnauthenticatedThenUnauthorized</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mvc.perform(get(<span class="string">&quot;/any&quot;</span>))</span><br><span class="line">        .andExpect(status().isUnauthorized())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="请求匹配"><a href="#请求匹配" class="headerlink" title="请求匹配"></a>请求匹配</h2><p>请求匹配的方法:</p>
<ul>
<li>最简单的，即匹配任何请求。</li>
<li>过URI模式进行匹配。Spring Security支持两种用于URI模式匹配的语言:Ant(如上所示)和正则表达式。</li>
</ul>
<h3 id="使用Ant进行匹配"><a href="#使用Ant进行匹配" class="headerlink" title="使用Ant进行匹配"></a>使用Ant进行匹配</h3><p>Ant是Spring Security用来匹配请求的<strong>默认</strong>语言。</p>
<ol>
<li>匹配单个端点或目录，如上例<code>/endpoint</code>所示</li>
<li>匹配端点或目录下的所有端点<br> 假设开发者不希望匹配<code>/endpoint</code>端点，而是希望匹配<code>/resource</code><strong>目录下的所有端点</strong>。在这种情况下，开发者可以执行以下操作: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">    .authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">        .requestMatchers(<span class="string">&quot;/resource/**&quot;</span>).hasAuthority(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
 上述规则可以理解为“如果请求是<code>/resource</code>或其某个子目录，需要<code>USER</code>权限;否则，只需要身份验证。”</li>
<li>请求中提取<strong>路径值</strong><br>如下所示: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">    .authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">        .requestMatchers(<span class="string">&quot;/resource/&#123;name&#125;&quot;</span>).access(<span class="keyword">new</span> <span class="title class_">WebExpressionAuthorizationManager</span>(<span class="string">&quot;#name == authentication.name&quot;</span>))</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li>
</ol>
<p>配置好授权以后，可以使用<em>Security的测试支持</em>以以下方式进行测试:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WithMockUser(authorities=&quot;USER&quot;)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">endpointWhenUserAuthorityThenAuthorized</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mvc.perform(get(<span class="string">&quot;/resource/jon&quot;</span>))</span><br><span class="line">        .andExpect(status().isOk());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WithMockUser</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">endpointWhenNotUserAuthorityThenForbidden</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mvc.perform(get(<span class="string">&quot;/resource/jon&quot;</span>))</span><br><span class="line">        .andExpect(status().isForbidden());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">anyWhenUnauthenticatedThenUnauthorized</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mvc.perform(get(<span class="string">&quot;/any&quot;</span>))</span><br><span class="line">        .andExpect(status().isUnauthorized())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用正则表达式进行匹配"><a href="#使用正则表达式进行匹配" class="headerlink" title="使用正则表达式进行匹配"></a>使用正则表达式进行匹配</h3><p>Spring Security支持根据正则表达式匹配请求。如果开发者想在子目录上应用比<code>**</code>更严格的匹配条件，这将很有用。</p>
<p>例如，考虑一个包含用户名和所有用户名必须是字母数字的规则的路径。可以使用<code>RegexRequestMatcher</code>来实现规则，像这样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">    .authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">        .requestMatchers(RegexRequestMatcher.regexMatcher(<span class="string">&quot;/resource/[A-Za-z0-9]+&quot;</span>)).hasAuthority(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">        .anyRequest().denyAll()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<h3 id="使用HTTP-Method进行匹配"><a href="#使用HTTP-Method进行匹配" class="headerlink" title="使用HTTP Method进行匹配"></a>使用HTTP Method进行匹配</h3><p>开发者也可以通过<em>HTTP方法</em>匹配规则。在通过授予的权限进行授权时，比如授予<em>读</em>或<em>写</em>权限时，这很有用。</p>
<p>如果要求所有<code>GET</code>都有<em>读</em>权限，所有<code>POST</code>都有<em>写</em>权限，可以这样做:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">    .authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">        .requestMatchers(HttpMethod.GET).hasAuthority(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">        .requestMatchers(HttpMethod.POST).hasAuthority(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">        .anyRequest().denyAll()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>上述规则可以理解为:“如果请求是<code>GET</code>，那么需要<em>读</em>权限;或者如果请求是<code>POST</code>，则需要<em>写</em>权限;否则，拒绝请求。”</p>
<blockquote>
<p><strong>默认情况下拒绝请求</strong>是一种推荐的安全实践，因为它将规则集转换为允许列表。</p>
</blockquote>
<p>配置好授权以后，可以使用<em>Security的测试支持</em>以以下方式进行测试:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WithMockUser(authorities=&quot;read&quot;)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getWhenReadAuthorityThenAuthorized</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mvc.perform(get(<span class="string">&quot;/any&quot;</span>))</span><br><span class="line">        .andExpect(status().isOk());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WithMockUser</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getWhenNoReadAuthorityThenForbidden</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mvc.perform(get(<span class="string">&quot;/any&quot;</span>))</span><br><span class="line">        .andExpect(status().isForbidden());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WithMockUser(authorities=&quot;write&quot;)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">postWhenWriteAuthorityThenAuthorized</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mvc.perform(post(<span class="string">&quot;/any&quot;</span>).with(csrf()))</span><br><span class="line">        .andExpect(status().isOk())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WithMockUser(authorities=&quot;read&quot;)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">postWhenNoWriteAuthorityThenForbidden</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mvc.perform(get(<span class="string">&quot;/any&quot;</span>).with(csrf()))</span><br><span class="line">        .andExpect(status().isForbidden());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="根据分派器-Dispatcher-类型匹配"><a href="#根据分派器-Dispatcher-类型匹配" class="headerlink" title="根据分派器(Dispatcher)类型匹配"></a>根据分派器(Dispatcher)类型匹配</h3><blockquote>
<p>!暂不支持XML!</p>
</blockquote>
<p>如前所述，Spring Security默认授权所有调度程序类型。即使在REQUESTdispatch上建立的安全上下文延续到后续dispatch，细微的不匹配有时也会导致意外的<code>AccessDeniedException</code>。</p>
<p>为了解决这个问题，可以配置Spring Security Java配置来允许分派器(Dispatcher)类型，比如<code>FORWARD</code>和<code>ERROR</code>，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">    .authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">        .dispatcherTypeMatchers(DispatcherType.FORWARD, DispatcherType.ERROR).permitAll()</span><br><span class="line">        .requestMatchers(<span class="string">&quot;/endpoint&quot;</span>).permitAll()</span><br><span class="line">        .anyRequest().denyAll()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h3 id="使用自定义匹配器"><a href="#使用自定义匹配器" class="headerlink" title="使用自定义匹配器"></a>使用自定义匹配器</h3><blockquote>
<p>!暂不支持XML!<br>在Java配置中，可以创建自己的<code>RequestMatcher</code>，并像这样提供给DSL:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RequestMatcher</span> <span class="variable">printview</span> <span class="operator">=</span> (request) -&gt; request.getParameter(<span class="string">&quot;print&quot;</span>) != <span class="literal">null</span>;</span><br><span class="line">http</span><br><span class="line">    .authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">        .requestMatchers(printview).hasAuthority(<span class="string">&quot;print&quot;</span>)</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为<code>RequestMatcher</code>是一个功能接口，所以开发者可以在DSL中将其作为lambda提供。<br>但是，如果要从请求中提取值，则需要有一个具体的类，因为这需要重写默认方法。</p>
</blockquote>
<p>配置好授权以后，可以使用<em>Security的测试支持</em>以以下方式进行测试:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WithMockUser(authorities=&quot;print&quot;)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printWhenPrintAuthorityThenAuthorized</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mvc.perform(get(<span class="string">&quot;/any?print&quot;</span>))</span><br><span class="line">        .andExpect(status().isOk());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WithMockUser</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printWhenNoPrintAuthorityThenForbidden</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mvc.perform(get(<span class="string">&quot;/any?print&quot;</span>))</span><br><span class="line">        .andExpect(status().isForbidden());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为Request授权"><a href="#为Request授权" class="headerlink" title="为Request授权"></a>为Request授权</h2><p>匹配请求后，用授权规则就可以对其进行授权。</p>
<p>下面是DSL中内置的授权规则:</p>
<ul>
<li><code>permitAll</code>: 请求不需要授权，是一个公共端点;注意，在这种情况下，永远不会从Session中检索Authentication</li>
<li><code>denyAll</code>: 请求在任何情况下都不被允许;注意，在这种情况下，永远不会从Session中检索Authentication</li>
<li><code>hasAuthority</code>: 请求要求认证具有与给定值匹配的G<code>rantedAuthority</code></li>
<li><code>hasRole</code>: <code>hasAuthority</code>的快捷方式，前缀为<code>ROLE_</code>或任何被配置为默认前缀的东西</li>
<li><code>hasAnyAuthority</code>: 请求要求认证具有与任何给定值匹配的<code>GrantedAuthority</code></li>
<li><code>hasAnyRole</code>: <code>hasAnyAuthority</code>的快捷方式，它以<code>ROLE_</code>或任何被配置为默认前缀的前缀为前缀</li>
<li><code>access</code>: 请求使用这个自定义<code>AuthorizationManager</code>来确定访问权限</li>
</ul>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">SecurityFilterChain <span class="title function_">web</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	http</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		.authorizeHttpRequests(authorize -&gt; authorize                                  </span><br><span class="line">            .dispatcherTypeMatchers(FORWARD, ERROR).permitAll() </span><br><span class="line">			.requestMatchers(<span class="string">&quot;/static/**&quot;</span>, <span class="string">&quot;/signup&quot;</span>, <span class="string">&quot;/about&quot;</span>).permitAll()         </span><br><span class="line">			.requestMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)                             </span><br><span class="line">			.requestMatchers(<span class="string">&quot;/db/**&quot;</span>).access(allOf(hasAuthority(<span class="string">&#x27;db&#x27;</span>), hasRole(<span class="string">&#x27;ADMIN&#x27;</span>)))   </span><br><span class="line">			.anyRequest().denyAll()                                                </span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明如下：</p>
<ul>
<li>授权分派<code>FORWARD</code>和<code>ERROR</code>以允许Spring MVC呈现视图、Spring Boot呈现error</li>
<li>指定任何用户都可以访问的多个URL模式。具体来说，如果URL以“&#x2F;resources&#x2F;”开头，等于“&#x2F;signup”或等于“&#x2F;about”，则任何用户都可以访问。</li>
<li>任何以“&#x2F;admin&#x2F;”开头的URL将被限制为具有“ROLE_ADMIN”角色的用户才能访问。<strong>注意，由于调用的是hasRole方法，因此不需要指定“ROLE_”前缀</strong>。</li>
<li>任何以“&#x2F;db&#x2F;”开头的URL都要求用户具有“db”权限以及“ROLE_ADMIN”权限。<strong>注意，由于使用的是hasRole表达式，因此不需要指定“ROLE_”前缀</strong>。</li>
<li>任何未匹配的URL都被拒绝访问。如果不想意外忘记更新授权规则，这是一个很好的策略。</li>
</ul>
<h2 id="使用授权数据库、策略代理或其他服务"><a href="#使用授权数据库、策略代理或其他服务" class="headerlink" title="使用授权数据库、策略代理或其他服务"></a>使用授权数据库、策略代理或其他服务</h2><p>如果开发者希望配置Spring Security以使用单独的服务进行授权，开发者可以创建自己的AuthorizationManager并将其与anyRequest匹配。</p>
<p>首先，自定义的<code>AuthorizationManager</code>举例如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">OpenPolicyAgentAuthorizationManager</span> <span class="keyword">implements</span> <span class="title class_">AuthorizationManager</span>&lt;RequestAuthorizationContext&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationDecision <span class="title function_">check</span><span class="params">(Supplier&lt;Authentication&gt; authentication, RequestAuthorizationContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// make request to Open Policy Agent</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以下方式将其添加到Spring Security:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">SecurityFilterChain <span class="title function_">web</span><span class="params">(HttpSecurity http, AuthorizationManager&lt;RequestAuthorizationContext&gt; authz)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	http</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		.authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">            .anyRequest().access(authz)</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="推荐permitAll而非的忽视"><a href="#推荐permitAll而非的忽视" class="headerlink" title="推荐permitAll而非的忽视"></a>推荐permitAll而非的忽视</h2><p>当开发者拥有<strong>静态资源</strong>时，很容易将SecurityFilterChain配置为忽略这些值,比如使用下文的<code>securityMatcher</code>。<br>更安全的方法是像这样使用<code>permitAll</code>来允许它们:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">    .authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">        .requestMatchers(<span class="string">&quot;/css/**&quot;</span>).permitAll()</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h2 id="安全-Security-匹配器"><a href="#安全-Security-匹配器" class="headerlink" title="安全(Security)匹配器"></a>安全(Security)匹配器</h2><p>使用securityMatchers来确定是否应该将给定的<code>HttpSecurity</code>应用于给定的请求。<br>同样，我们可以使用requestMatchers来确定应该应用于给定请求的授权规则。</p>
<blockquote>
<p>如果<code>securityMatcher</code>不匹配，则SecurityFilterChain将不被执行。<br>举例如下:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		http</span><br><span class="line">			.securityMatcher(<span class="string">&quot;/api/**&quot;</span>)                            </span><br><span class="line">			.authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">				.requestMatchers(<span class="string">&quot;/user/**&quot;</span>).hasRole(<span class="string">&quot;USER&quot;</span>)       </span><br><span class="line">				.requestMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)     </span><br><span class="line">				.anyRequest().authenticated()                      </span><br><span class="line">			)</span><br><span class="line">			.formLogin(withDefaults());</span><br><span class="line">		<span class="keyword">return</span> http.build();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法级别授权"><a href="#方法级别授权" class="headerlink" title="方法级别授权"></a>方法级别授权</h1><blockquote>
<p>默认情况下，Spring Boot Starter Security不启用方法级授权。<br>需要程序中通过用<code>@EnableMethodSecurity</code>注解来启用它，任何@Configuration类都可以，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableMethodSecurity</span></span><br></pre></td></tr></table></figure>
<p>之后， 可以对Spring管理的类和方法使用<code>@PreAuthorize</code>, <code>@PostAuthorize</code>, <code>@PreFilter</code>, 和<code>@PostFilter</code>注解，以授权方法调用，包括输入参数和返回值。</p>
</blockquote>
<h2 id="方法级别授权工作原理"><a href="#方法级别授权工作原理" class="headerlink" title="方法级别授权工作原理"></a>方法级别授权工作原理</h2><p>Spring Security的方法授权支持很方便:</p>
<ul>
<li>抽取细粒度的授权逻辑;例如，当授权决策需要使用方法参数和返回值时。</li>
<li>在服务层加强安全性</li>
<li>在风格上倾向于基于注解的配置，而不是基于<code>HttpSecurity</code>的配置</li>
</ul>
<p>而且由于Method Security是使用<code>Spring AOP</code>构建的，因此开发者可以根据需要使用它的所有特性来覆盖Spring Security的默认值。</p>
<p>方法授权是<em>方法前</em>和<em>方法后</em>授权的组合。考虑一个以以下方式进行注解的Service bean:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCustomerService</span> &#123;</span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;permission:read&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@PostAuthorize(&quot;returnObject.owner == authentication.name&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Customer <span class="title function_">readCustomer</span><span class="params">(String id)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当方法安全被启用时，对<code>MyCustomerService#readCustomer</code>的调用可能看起来像这样:<br><img src="/img/IT/SpringSecurity/%E5%9F%BA%E4%BA%8EServlet%E7%9A%84Spring-Security-Authorization%E9%9B%86%E6%88%90-2.png" alt="Http Request权限认证"></p>
<ol>
<li>Spring AOP调用<code>readCustomer</code>的代理方法。在代理的其他顾问中，它调用与<code>@PreAuthorize</code>切入点匹配的<code>AuthorizationManagerBeforeMethodInterceptor</code></li>
<li>拦截器调用<code>PreAuthorizeAuthorizationManager#check</code></li>
<li>授权管理器使用<code>MethodSecurityExpressionHandler</code>来解析注解的SpEL表达式，并从包含<code>Supplier&lt;Authentication&gt;</code>和<code>MethodInvocation</code>的<code>MethodSecurityExpressionRoot</code>中构造相应的<code>EvaluationContext</code>。</li>
<li>拦截器使用这个上下文对表达式求值;具体来说，它从<code>Supplier</code>读取<code>Authentication</code>，并检查它是否在其权限集合中具有读取权限</li>
<li>如果评估通过，那么Spring AOP将继续调用该方法。</li>
<li>如果没有，拦截器生成一个<code>AuthorizationDeniedEvent</code>并抛出一个<code>AccessDeniedException</code>，由<code>ExceptionTranslationFilter</code>捕获并向响应返回一个403状态码</li>
<li>方法返回后，Spring AOP调用一个与<code>@PostAuthorize</code>切入点匹配的<code>AuthorizationManagerAfterMethodInterceptor</code>，操作与上面相同，但是使用的是<code>PostAuthorizeAuthorizationManager</code></li>
<li>如果计算通过(在本例中，返回值属于登录的用户)，处理将继续正常进行</li>
<li>如果没有，则拦截器生成<code>AuthorizationDeniedEvent</code>并抛出<code>AccessDeniedException</code>，由<code>ExceptionTranslationFilter</code>捕获并向响应返回一个403状态码</li>
</ol>
<blockquote>
<p>如果不是在HTTP请求的上下文中调用该方法，需要自己处理<code>AccessDeniedException</code></p>
</blockquote>
<h3 id="多个注解是顺序执行的"><a href="#多个注解是顺序执行的" class="headerlink" title="多个注解是顺序执行的"></a>多个注解是顺序执行的</h3><p>如上所示，如果方法调用涉及多个Method Security注解，这些注解将被依次执行。它们可以被认为是”与逻辑”关系。换句话说，要授权调用，所有注解检查都需要通过授权。</p>
<h3 id="不支持重复注解"><a href="#不支持重复注解" class="headerlink" title="不支持重复注解"></a>不支持重复注解</h3><p>也就是说，不支持在同一方法上定义重复相同的注解。例如，不能在同一个方法上使用两次@PreAuthorize。</p>
<p>相反，使用SpEL的布尔(boolean)支持或使用它对委托的Bean的支持，在独立的Bean中实现需要重复注解实现的逻辑。</p>
<h3 id="每个注解都有自己的切入点"><a href="#每个注解都有自己的切入点" class="headerlink" title="每个注解都有自己的切入点"></a>每个注解都有自己的切入点</h3><p>每个注解都有自己的切入点实例，该实例会查找该注解或对应的元注解(meta-annotation)，从该方法及其封装类开始遍历其全部对象继承树。</p>
<h3 id="每个注解都有自己的方法拦截器"><a href="#每个注解都有自己的方法拦截器" class="headerlink" title="每个注解都有自己的方法拦截器"></a>每个注解都有自己的方法拦截器</h3><p>每个注解都有自己专用的方法拦截器。这样做的原因是为了使事情更加可组合。例如，如果需要，可以禁用Spring Security默认设置，只生成<code>@PostAuthorize</code>方法拦截器。</p>
<p>方法拦截器如下:</p>
<ul>
<li>对于<code>@PreAuthorize</code>, Spring Security使用<code>AuthenticationManagerBeforeMethodInterceptor#preAuthorization</code>，在其中使用<code>PreAuthorizeAuthorizationManager</code></li>
<li>对于<code>@PostAuthorize</code>, Spring Security使用<code>AuthenticationManagerAfterMethodInterceptor#postAuthorize</code>，在其中使用<code>PostAuthorizeAuthorizationManager</code></li>
<li>对于<code>@PreFilter</code>, Spring Security使用<code>PreFilterAuthorizationMethodInterceptor</code></li>
<li>对于<code>@PostFilter</code>, Spring Security使用<code>PostFilterAuthorizationMethodInterceptor</code></li>
<li>对于<code>@Secured</code>, Spring Security使用<code>AuthenticationManagerBeforeMethodInterceptor#secured</code>，在其中使用<code>SecuredAuthorizationManager</code></li>
<li>对于<code>JSR-250注解</code>，Spring Security使用<code>AuthenticationManagerBeforeMethodInterceptor#jsr250</code>，在其中使用<code>Jsr250AuthorizationManager</code></li>
</ul>
<p>一般来说，可以认为当添加@EnableMethodSecurity时，Spring Security生成了一下拦截器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="keyword">static</span> Advisor <span class="title function_">preAuthorizeMethodInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> AuthorizationManagerBeforeMethodInterceptor.preAuthorize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="keyword">static</span> Advisor <span class="title function_">postAuthorizeMethodInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> AuthorizationManagerAfterMethodInterceptor.postAuthorize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="keyword">static</span> Advisor <span class="title function_">preFilterMethodInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> AuthorizationManagerBeforeMethodInterceptor.preFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="keyword">static</span> Advisor <span class="title function_">postFilterMethodInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> AuthorizationManagerAfterMethodInterceptor.postFilter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="建议使用授予权限而非使用复杂的SpEL表达式"><a href="#建议使用授予权限而非使用复杂的SpEL表达式" class="headerlink" title="建议使用授予权限而非使用复杂的SpEL表达式"></a>建议使用授予权限而非使用复杂的SpEL表达式</h3><p>开发者可能经常不由自主的引入下面这样的表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;permission:read&#x27;) || hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br></pre></td></tr></table></figure>
<p>然而，也可以采用将权限<em>permission:read</em>授予角色<em>ROLE_ADMIN</em>的方法。比如采用<code>RoleHierarchy</code>的方式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">static</span> RoleHierarchy <span class="title function_">roleHierarchy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoleHierarchyImpl</span>(<span class="string">&quot;ROLE_ADMIN &gt; permission:read&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>MethodSecurityExpressionHandler</code>实例中设置它。这样就有了一个更简单的<code>@PreAuthorize</code>表达式，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;permission:read&#x27;)&quot;)</span></span><br></pre></td></tr></table></figure>
<p>或者，在可能的情况下，将特定于应用程序的授权逻辑调整为在登录时授予的用户权限。</p>
<h2 id="比较请求级和方法级授权"><a href="#比较请求级和方法级授权" class="headerlink" title="比较请求级和方法级授权"></a>比较请求级和方法级授权</h2><p>什么时候应该使用方法级授权而不是请求级授权?其中一些可以归结为习惯;但是，请参考一下优势列表来做出决定：</p>
<table>
    <tr>
        <th></th>
        <th>请求级 request-level</th>
        <th>方法级 method-level</th>
    </tr>
    <tr>
        <th>授权类型</th>
        <td>粗粒度的</td>
        <td>细粒度的</td>
    </tr>
    <tr>
        <th>配置位置</th>
        <td>在Config类中声明</td>
        <td>限定在Method声明中</td>
    </tr>
    <tr>
        <th>配置风格</th>
        <td>DSL</td>
        <td>注解</td>
    </tr>
    <tr>
        <th>授权定义</th>
        <td>程序化的</td>
        <td>SpEL</td>
    </tr>
</table>

<h2 id="使用注解进行授权"><a href="#使用注解进行授权" class="headerlink" title="使用注解进行授权"></a>使用注解进行授权</h2><p>Spring Security启用方法级授权支持的主要方式是通过可以添加到方法、类和接口中的注解。</p>
<h3 id="使用-PreAuthorize授权方法调用"><a href="#使用-PreAuthorize授权方法调用" class="headerlink" title="使用@PreAuthorize授权方法调用"></a>使用@PreAuthorize授权方法调用</h3><p>当方法安全启用时，可以在方法上使用<code>@PreAuthorize</code>注解，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankService</span> &#123;</span><br><span class="line">	<span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> Account <span class="title function_">readAccount</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// ... is only invoked if the `Authentication` has the `ROLE_ADMIN` authority</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着只有当提供的表达式<code>hasRole(&#39;ADMIN&#39;)</code>通过时才能调用该方法。<br>可以使用以下代码测试这个类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">BankService bankService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WithMockUser(roles=&quot;ADMIN&quot;)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">readAccountWithAdminRoleThenInvokes</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="built_in">this</span>.bankService.readAccount(<span class="string">&quot;12345678&quot;</span>);</span><br><span class="line">    <span class="comment">// ... assertions</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WithMockUser(roles=&quot;WRONG&quot;)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">readAccountWithWrongRoleThenAccessDenied</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(</span><br><span class="line">        () -&gt; <span class="built_in">this</span>.bankService.readAccount(<span class="string">&quot;12345678&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>@PreAuthorize</code>也可以是元注解，在类或接口级别定义，并使用SpEL授权表达式。</p>
</blockquote>
<p>虽然<code>@PreAuthorize</code>对于声明所需的权限非常有帮助，但它也可以用于计算涉及方法参数的更复杂的表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankService</span> &#123;</span><br><span class="line">	<span class="meta">@PreAuthorize(&quot;#usename == authentication.name&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> Account <span class="title function_">readAccount</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="comment">// ... is only invoked if the `Authentication#getName` equals username parameter.</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码段通过比较<code>username</code>参数与<code>Authentication#getName</code>来确保用户只能请求属于他们的账户。<br>结果是，只有当请求参数中的username与登录的用户名匹配时，才会调用上述方法。如果没有，Spring Security将抛出一个<code>AccessDeniedException</code>并返回一个403状态码。</p>
<h3 id="使用-PostAuthorize的授权方法结果"><a href="#使用-PostAuthorize的授权方法结果" class="headerlink" title="使用@PostAuthorize的授权方法结果"></a>使用<code>@PostAuthorize</code>的授权方法结果</h3><p>当方法安全启用时，可以在方法上使用<code>@PostAuthorize</code>注解，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankService</span> &#123;</span><br><span class="line">	<span class="meta">@PostAuthorize(&quot;returnObject.owner == authentication.name&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> Account <span class="title function_">readAccount</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// ... is only returned if the `Account` belongs to the logged in user</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着该方法只能在提供的表达式<code>returnObject.owner == authentication.name</code>通过时返回值。returnbject表示要返回的Account对象。</p>
<p>可以使用以下代码测试这个类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">BankService bankService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WithMockUser(username=&quot;owner&quot;)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">readAccountWhenOwnedThenReturns</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="built_in">this</span>.bankService.readAccount(<span class="string">&quot;12345678&quot;</span>);</span><br><span class="line">    <span class="comment">// ... assertions</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WithMockUser(username=&quot;wrong&quot;)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">readAccountWhenNotOwnedThenAccessDenied</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(</span><br><span class="line">        () -&gt; <span class="built_in">this</span>.bankService.readAccount(<span class="string">&quot;12345678&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>@PostAuthorize</code>也可以是元注解，在类或接口级别定义，并使用SpEL授权表达式。<br><code>@PostAuthorize</code>在防御不安全的直接对象引用时特别有用。实际上，它可以被定义为元注解，如下所示:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@PostAuthorize(&quot;returnObject.owner == authentication.name&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequireOwnership &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可以将Service的注解如下修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankService</span> &#123;</span><br><span class="line">	<span class="meta">@RequireOwnership</span></span><br><span class="line">	<span class="keyword">public</span> Account <span class="title function_">readAccount</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// ... is only returned if the `Account` belongs to the logged in user</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是，只有当Account的所有者属性与登录的用户名匹配时，上述方法才会返回Account。如果没有，Spring Security将抛出一个<code>AccessDeniedException</code>并返回一个403状态码。</p>
<h3 id="用-PreFilter过滤方法参数"><a href="#用-PreFilter过滤方法参数" class="headerlink" title="用@PreFilter过滤方法参数"></a>用@PreFilter过滤方法参数</h3><blockquote>
<p><code>@PreFilter</code>还不支持kotlin特定的数据类型<br>当方法安全启用时，可以在方法上使用<code>@PreFilter</code>注解，如下所示:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankService</span> &#123;</span><br><span class="line">	<span class="meta">@PreFilter(&quot;filterObject.owner == authentication.name&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> Collection&lt;Account&gt; <span class="title function_">updateAccounts</span><span class="params">(Account... accounts)</span> &#123;</span><br><span class="line">        <span class="comment">// ... `accounts` will only contain the accounts owned by the logged-in user</span></span><br><span class="line">        <span class="keyword">return</span> updated;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着从Accounts中过滤出任何不满足<code>filterObject.owner == authentication.name</code>的值。filterObject表示帐户中的每个帐户，用于测试每个帐户。<br>可以使用以下代码测试这个类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">BankService bankService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WithMockUser(username=&quot;owner&quot;)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateAccountsWhenOwnedThenReturns</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Account</span> <span class="variable">ownedBy</span> <span class="operator">=</span> ...</span><br><span class="line">    <span class="type">Account</span> <span class="variable">notOwnedBy</span> <span class="operator">=</span> ...</span><br><span class="line">    Collection&lt;Account&gt; updated = <span class="built_in">this</span>.bankService.updateAccounts(ownedBy, notOwnedBy);</span><br><span class="line">    assertThat(updated).containsOnly(ownedBy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@PreFilter也可以是元注解，在类或接口级别定义，并使用SpEL授权表达式。<br>@PreFilter支持数组、集合、映射和流(只要流是打开的)。<br>例如，上面的updateAccounts声明将以与下面四个声明相同的方式起作用:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreFilter(&quot;filterObject.owner == authentication.name&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;Account&gt; <span class="title function_">updateAccounts</span><span class="params">(Account[] accounts)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@PreFilter(&quot;filterObject.owner == authentication.name&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;Account&gt; <span class="title function_">updateAccounts</span><span class="params">(Collection&lt;Account&gt; accounts)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@PreFilter(&quot;filterObject.value.owner == authentication.name&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;Account&gt; <span class="title function_">updateAccounts</span><span class="params">(Map&lt;String, Account&gt; accounts)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@PreFilter(&quot;filterObject.owner == authentication.name&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;Account&gt; <span class="title function_">updateAccounts</span><span class="params">(Stream&lt;Account&gt; accounts)</span></span><br></pre></td></tr></table></figure>
<p>结果是，上述方法将只具有其所有者属性与登录用户名匹配的Account实例。</p>
<h3 id="使用-PostFilter过滤方法结果"><a href="#使用-PostFilter过滤方法结果" class="headerlink" title="使用@PostFilter过滤方法结果"></a>使用@PostFilter过滤方法结果</h3><blockquote>
<p>@PostFilter还不支持kotlin特定的数据类型<br>当方法安全启用时，可以在方法上使用<code>@PostFilter</code>注解，如下所示:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class BankService &#123;</span><br><span class="line">	@PostFilter(&quot;filterObject.owner == authentication.name&quot;)</span><br><span class="line">	public Collection&lt;Account&gt; readAccounts(String... ids) &#123;</span><br><span class="line">        // ... the return value will be filtered to only contain the accounts owned by the logged-in user</span><br><span class="line">        return accounts;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着从返回值中过滤出任何不满足<code>filterObject.owner == authentication.name</code>的值。filterObject表示accounts中的每个帐户，用于测试每个帐户。<br>可以使用以下代码测试这个类:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">BankService bankService;</span><br><span class="line"></span><br><span class="line">@WithMockUser(username=&quot;owner&quot;)</span><br><span class="line">@Test</span><br><span class="line">void readAccountsWhenOwnedThenReturns() &#123;</span><br><span class="line">    Collection&lt;Account&gt; accounts = this.bankService.updateAccounts(&quot;owner&quot;, &quot;not-owner&quot;);</span><br><span class="line">    assertThat(accounts).hasSize(1);</span><br><span class="line">    assertThat(accounts.get(0).getOwner()).isEqualTo(&quot;owner&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@PostFilter也可以是元注解，在类或接口级别定义，并使用SpEL授权表达式。<br>@PostFilter支持数组、集合、映射和流(只要流是打开的)。<br>例如，上面的readAccounts声明将以与下面三个声明相同的方式起作用:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostFilter(&quot;filterObject.owner == authentication.name&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Account[] readAccounts(String... ids)</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostFilter(&quot;filterObject.value.owner == authentication.name&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, Account&gt; <span class="title function_">readAccounts</span><span class="params">(String... ids)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@PostFilter(&quot;filterObject.owner == authentication.name&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Stream&lt;Account&gt; <span class="title function_">readAccounts</span><span class="params">(String... ids)</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-Secured授权方法调用"><a href="#使用-Secured授权方法调用" class="headerlink" title="使用@Secured授权方法调用"></a>使用@Secured授权方法调用</h3><blockquote>
<p><code>@Secured</code>是授权调用的遗留功能，已被@PreAuthorize，建议改为@PreAuthorize。</p>
</blockquote>
<h3 id="使用JSR-250注解授权方法调用"><a href="#使用JSR-250注解授权方法调用" class="headerlink" title="使用JSR-250注解授权方法调用"></a>使用JSR-250注解授权方法调用</h3><p>如果开发者想使用<code>JSR-250注解</code>，Spring Security也支持。@PreAuthorize表达能力更强，推荐使用。</p>
<p>要使用JSR-250注解，应该首先修改Method Security声明，使其生效，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableMethodSecurity(jsr250Enabled = true)</span></span><br></pre></td></tr></table></figure>
<p>这将导致Spring Security发布相应的方法拦截器，该拦截器授权带有<code>@RolesAllowed</code>、<code>@PermitAll</code>和<code>@DenyAll</code>注解的方法、类和接口。</p>
<h3 id="在类或接口级别声明注解"><a href="#在类或接口级别声明注解" class="headerlink" title="在类或接口级别声明注解"></a>在类或接口级别声明注解</h3><p>它还支持在类和接口级别使用方法安全性注解。</p>
<p>如果是在类级别，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;ROLE_USER&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/endpoint&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">endpoint</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，所有方法继承类级行为。<br>或者，如果它在类和方法级别都声明如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;ROLE_USER&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/endpoint&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;ROLE_ADMIN&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">endpoint</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，<strong>声明注解的方法重写类级注解</strong>。<br>接口也是如此，不同的是，<strong>如果一个类从两个不同的接口继承了注解，那么启动将失败</strong>。这是因为Spring Security无法识别开发者想使用哪一个。<br>在这种情况下，可以通过向具体方法添加注解来解决歧义。</p>
<h3 id="使用元注解"><a href="#使用元注解" class="headerlink" title="使用元注解"></a>使用元注解</h3><p>方法安全性支持元注解。这意味着开发者可以根据特定于应用程序的用例使用任何注解并提高可读性。</p>
<p>例如，可以简化<code>@PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)</code>为<code>@IsAdmin</code>，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IsAdmin &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>结果是，在开发者的安全方法上，开发者现在可以执行以下操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankService</span> &#123;</span><br><span class="line">	<span class="meta">@IsAdmin</span></span><br><span class="line">	<span class="keyword">public</span> Account <span class="title function_">readAccount</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// ... is only returned if the `Account` belongs to the logged in user</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这使得方法定义更具可读性。</p>
<h3 id="启用特定注解"><a href="#启用特定注解" class="headerlink" title="启用特定注解"></a>启用特定注解</h3><p>关闭<code>@EnableMethodSecurity</code>的预配置，并替换为自定义的。</p>
<ul>
<li>如果想自定义<code>AuthorizationManager</code>或<code>Pointcut</code>，可以选择这样做。</li>
<li>或者可能只想启用特定的注解，比如<code>@PostAuthorize</code>。<br>举例如下:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableMethodSecurity(prePostEnabled = false)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MethodSecurityConfig</span> &#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">	Advisor <span class="title function_">postAuthorize</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> AuthorizationManagerBeforeMethodInterceptor.postAuthorize();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面的代码片段通过首先禁用Method Security的预配置，然后生成<code>@PostAuthorize</code>拦截器来实现这一点。</li>
</ul>
<h2 id="使用进行授权"><a href="#使用进行授权" class="headerlink" title="使用进行授权"></a>使用<intercept-methods>进行授权</h2><blockquote>
<p>推荐使用Spring Security的基于注解的支持来实现方法安全性</p>
</blockquote>
<h2 id="以编程方式授权方法"><a href="#以编程方式授权方法" class="headerlink" title="以编程方式授权方法"></a>以编程方式授权方法</h2><p>基于java而不是基于SpEL实现复杂的授权规则有很多方法。这使得用户可以使用完整Java语言特性，从而<strong>提高可测试性和流程控制</strong>。</p>
<h3 id="方法一-在SpEL中使用自定义Bean"><a href="#方法一-在SpEL中使用自定义Bean" class="headerlink" title="方法一: 在SpEL中使用自定义Bean"></a>方法一: 在SpEL中使用自定义Bean</h3><p>首先，像下面这样声明一个bean，它有一个接受<code>MethodSecurityExpressionOperations</code>实例的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;authz&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationLogic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">decide</span><span class="params">(MethodSecurityExpressionOperations operations)</span> &#123;</span><br><span class="line">        <span class="comment">// ... authorization logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在注解中如下引用自定义的Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;@authz.decide(#root)&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/endpoint&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">endpoint</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Security将为每个方法调用调用该bean上的给定方法。<br>这样做的好处是，所有授权逻辑都在一个单独的类中，可以独立地对其进行单元测试和正确性验证。它还可以使用完整Java语言特性。</p>
<h3 id="方法二-使用自定义授权管理器-Authorization-Manager"><a href="#方法二-使用自定义授权管理器-Authorization-Manager" class="headerlink" title="方法二: 使用自定义授权管理器(Authorization Manager)"></a>方法二: 使用自定义授权管理器(Authorization Manager)</h3><p>首先，声明一个授权管理器实例，比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthorizationManager</span> <span class="keyword">implements</span> <span class="title class_">AuthorizationManager</span>&lt;MethodInvocation&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> AuthorizationDecision <span class="title function_">check</span><span class="params">(Supplier&lt;Authentication&gt; authentication, MethodInvocation invocation)</span> &#123;</span><br><span class="line">        <span class="comment">// ... authorization logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，生成带有切入点的方法拦截器，该切入点对应于开发者希望<code>AuthorizationManager</code>运行的时机。<br>例如，可以这样替换<code>@PreAuthorize</code>和<code>@PostAuthorize</code>的工作方式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableMethodSecurity(prePostEnabled = false)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MethodSecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">	Advisor <span class="title function_">postAuthorize</span><span class="params">(MyAuthorizationManager manager)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> AuthorizationManagerBeforeMethodInterceptor.preAuthorize(manager);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">	Advisor <span class="title function_">postAuthorize</span><span class="params">(MyAuthorizationManager manager)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> AuthorizationManagerAfterMethodInterceptor.postAuthorize(manager);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以使用<code>AuthorizationInterceptorsOrder</code>中指定的Order常量将拦截器放在Spring Security方法拦截器之间。</p>
</blockquote>
<h3 id="方法三-自定义表达式处理"><a href="#方法三-自定义表达式处理" class="headerlink" title="方法三: 自定义表达式处理"></a>方法三: 自定义表达式处理</h3><p>自定义每个SpEL表达式的处理方式。<br>要做到这一点，可以公开一个自定义<code>MethodSecurityExpressionHandler</code>，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">static</span> MethodSecurityExpressionHandler <span class="title function_">methodSecurityExpressionHandler</span><span class="params">(RoleHierarchy roleHierarchy)</span> &#123;</span><br><span class="line">	<span class="type">DefaultMethodSecurityExpressionHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMethodSecurityExpressionHandler</span>();</span><br><span class="line">	handler.setRoleHierarchy(roleHierarchy);</span><br><span class="line">	<span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用一个<strong>静态方法</strong>公开<code>MethodSecurityExpressionHandler</code>，以确保Spring在初始化Spring Security的Method Security的@Configuration类之前发布它</p>
</blockquote>
<p>开发者还可以子类化<code>DefaultMessageSecurityExpressionHandler</code>，以在默认值之外添加自定义授权表达式。</p>
<h2 id="使用AspectJ进行授权"><a href="#使用AspectJ进行授权" class="headerlink" title="使用AspectJ进行授权"></a>使用AspectJ进行授权</h2><h3 id="用自定义切入点匹配方法"><a href="#用自定义切入点匹配方法" class="headerlink" title="用自定义切入点匹配方法"></a>用自定义切入点匹配方法</h3><p>由于Method Security基于Spring AOP构建，因此可以声明与注解无关的模式，类似于请求级授权。这具有<strong>集中方法级授权规则</strong>的潜在优势。</p>
<p>例如，可以通过生成自己的Adviso来为服务层匹配AOP表达式和授权规则，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="keyword">static</span> Advisor <span class="title function_">protectServicePointcut</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">JdkRegexpMethodPointcut</span> <span class="variable">pattern</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdkRegexpMethodPointcut</span>();</span><br><span class="line">    pattern.setPattern(<span class="string">&quot;execution(* com.mycompany.*Service.*(..))&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthorizationManagerBeforeMethodInterceptor</span>(pattern, hasRole(<span class="string">&quot;USER&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与AspectJ-Byte-weaving"><a href="#与AspectJ-Byte-weaving" class="headerlink" title="与AspectJ Byte-weaving"></a>与AspectJ Byte-weaving</h3><p><strong>有时</strong>可以通过使用AspectJ将Spring Security <code>advice</code>编织到bean的字节码中来<strong>增强性能</strong>。</p>
<p>在设置了AspectJ之后，在@EnableMethodSecurity注解中声明使用AspectJ:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableMethodSecurity(mode=AdviceMode.ASPECTJ)</span></span><br></pre></td></tr></table></figure>
<p>结果是Spring Security将它的<code>advice</code>作为<code>AspectJ Advisor</code>发布，这样它们就可以被相应地编织进来。</p>
<h2 id="指定Order"><a href="#指定Order" class="headerlink" title="指定Order"></a>指定Order</h2><p>如前所述，每个注解都有一个Spring AOP方法拦截器，每个注解在Spring AOP Advisor链中都有固定的位置。<br>比如说，<code>@PreFilter</code>方法拦截器的Order是100，<code>@PreAuthorize</code>的Order是200，以此类推。</p>
<p>之所以重要，是因为还有其他基于AOP的注解，如<code>@EnableTransactionManagement</code>，其<code>order</code>为<code>Integer.MAX_VALUE</code>。换句话说，默认情况下，它们位于advisor链的末端。</p>
<p>有时，在Spring Security之前执行其他Advice可能很有价值。例如，如果开发者有一个带有<code>@Transactional</code>和<code>@PostAuthorize</code>注解的方法，开发者可能希望在<code>@PostAuthorize</code>运行时事务仍然是打开的，以便允许<code>AccessDeniedException</code>将触发回滚。</p>
<p>为了让<code>@EnableTransactionManagemen</code>t在方法授权建议运行之前打开一个事务，可以像这样设置<code>@EnableTransactionManagement</code>的Order:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement(order = 0)</span></span><br></pre></td></tr></table></figure>
<p>由于最早的方法拦截器(@PreFilter)被设置为100的Order，因此设置为0意味着事务通知将在所有Spring Security advice之前运行。</p>
<h2 id="使用SpEL表达授权"><a href="#使用SpEL表达授权" class="headerlink" title="使用SpEL表达授权"></a>使用SpEL表达授权</h2><p>Spring Security将其所有授权字段(Field)和方法(Method)封装在一组根对象中。最通用的根对象叫做<code>SecurityExpressionRoot</code>，它构成了<code>MethodSecurityExpressionRoot</code>的基础。Spring Security在准备计算授权表达式的值时将这个根对象传递给<code>MethodSecurityEvaluationContext</code>。</p>
<h3 id="使用授权表达式字段和方法"><a href="#使用授权表达式字段和方法" class="headerlink" title="使用授权表达式字段和方法"></a>使用授权表达式<em>字段</em>和<em>方法</em></h3><p>它提供的第一件事是为SpEL表达式提供一组增强的授权字段和方法。以下是对最常见方法的快速概述:</p>
<ul>
<li><code>permitAll</code>: 该方法不需要调用授权;注意，在这种情况下，永远不会从会话中检索Authentication</li>
<li><code>denyAll</code>: 在任何情况下都不允许使用该方法;注意，在这种情况下，永远不会从会话中检索Authentication</li>
<li><code>hasAuthority</code>: 该方法要求认证具有与给定值匹配的GrantedAuthority</li>
<li><code>hasRole</code>: hasAuthority的快捷方式，前缀为ROLE_或任何被配置为默认前缀的东西</li>
<li><code>hasAnyAuthority</code>: 该方法要求认证具有与任何给定值匹配的GrantedAuthority</li>
<li><code>hasAnyRole</code>: <code>hasAnyAuthority</code>的快捷方式，它以ROLE_或任何被配置为默认前缀的前缀为前缀</li>
<li><code>hasPermission</code>: 关联到<code>PermissionEvaluator</code>实例进行对象级授权<br>下面简要介绍一下最常见的领域:</li>
<li>authentication: 与此方法调用关联的Authentication实例</li>
<li>principal: 与此方法调用关联的<code>Authentication#getPrincipal</code></li>
</ul>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Component</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="comment">// 任何人不得以任何理由调用此方法</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;denyAll&quot;)</span> </span><br><span class="line">    MyResource <span class="title function_">myDeprecatedMethod</span><span class="params">(...)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法只能由授予ROLE_ADMIN权限的认证调用</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span> </span><br><span class="line">    MyResource <span class="title function_">writeResource</span><span class="params">(...)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法只能由授予db和ROLE_ADMIN权限的身份验证调用</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;db&#x27;) and hasRole(&#x27;ADMIN&#x27;)&quot;)</span> </span><br><span class="line">    MyResource <span class="title function_">deleteResource</span><span class="params">(...)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法只能由aud声明等于“my-audience”的principal调用。</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;principal.claims[&#x27;aud&#x27;] == &#x27;my-audience&#x27;&quot;)</span> </span><br><span class="line">    MyResource <span class="title function_">readResource</span><span class="params">(...)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有当bean authz的检查方法返回true时，才能调用此方法</span></span><br><span class="line">	<span class="meta">@PreAuthorize(&quot;@authz.check(authentication, #root)&quot;)</span></span><br><span class="line">    MyResource <span class="title function_">shareResource</span><span class="params">(...)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用方法参数"><a href="#使用方法参数" class="headerlink" title="使用方法参数"></a>使用方法参数</h2><p>Spring Security提供了一种发现方法参数的机制，以便也可以在SpEL表达式中访问它们。</p>
<p>为了获得完整的引用，Spring Security使用<code>DefaultSecurityParameterNameDiscoverer</code>来发现参数名。默认情况下，将为方法尝试以下选项。</p>
<p>如果Spring Security的<code>@P</code>注解出现在方法的<strong>单个</strong>参数上，则使用该值。下面的例子使用了@P注解:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasPermission(#c, &#x27;write&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateContact</span><span class="params">(<span class="meta">@P(&quot;c&quot;)</span> Contact contact)</span>;</span><br></pre></td></tr></table></figure>
<p>此表达式的目的是要求当前Authentication具有专门针对此Contact实例的写权限。</p>
<p>在幕后，这是通过使用<code>AnnotationParameterNameDiscoverer</code>实现的，开发者可以自定义它以支持任何指定注解的value属性。</p>
<ul>
<li>如果Spring Data的@Param注解出现在该方法的至少一个参数上，则使用该值。下面的例子使用了@Param注解:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;#n == authentication.name&quot;)</span></span><br><span class="line">Contact <span class="title function_">findContactByName</span><span class="params">(<span class="meta">@Param(&quot;n&quot;)</span> String name)</span>;</span><br></pre></td></tr></table></figure>
  这个表达式的目的是要求name等于authentication#getName，以便授权调用。</li>
<li>如果使用<code>-parameters</code>参数编译代码，则使用标准JDK反射API来发现参数名称。这对类和接口都有效。</li>
<li>最后，如果使用debug符号编译代码，则通过使用debug符号发现参数名。这<strong>不适用于接口</strong>，因为它们没有关于参数名称的调试信息。对于接口，必须使用<em>注解</em>或<code>-parameters</code>方法。</li>
</ul>
<h1 id="域对象安全访问控制-ACL"><a href="#域对象安全访问控制-ACL" class="headerlink" title="域对象安全访问控制(ACL)"></a>域对象安全访问控制(ACL)</h1><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/reference/servlet/authorization/acls.html">参考</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://silentstone.cn">Dickens Hu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://silentstone.cn/IT/Spring%20Security/%E5%9F%BA%E4%BA%8EServlet%E7%9A%84Spring%20Security%20Authorization%E9%9B%86%E6%88%90/">http://silentstone.cn/IT/Spring%20Security/%E5%9F%BA%E4%BA%8EServlet%E7%9A%84Spring%20Security%20Authorization%E9%9B%86%E6%88%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://silentstone.cn" target="_blank">静石随笔</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/IT/Spring%20Security/%E6%9E%B6%E6%9E%84/Spring%20Security%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81%E6%9E%B6%E6%9E%84/" title="Spring Security权限认证架构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring Security权限认证架构</div></div></a></div><div class="next-post pull-right"><a href="/IT/Spring%20Security/%E5%9F%BA%E4%BA%8EServlet%E7%9A%84Spring%20Security%20Authentication%E9%9B%86%E6%88%90/" title="基于Servlet的Spring Security Authentication集成"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">基于Servlet的Spring Security Authentication集成</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Dickens Hu</div><div class="author-info__description">工作学习过程中的各种笔记、记录、总结，以及生活中偶尔的感慨或者纯粹的记录。很高兴你发现了这里，enjoy!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/pumasun"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Http-Request%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81"><span class="toc-number">1.</span> <span class="toc-text">Http Request权限认证</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8E%88%E6%9D%83%E7%BB%84%E4%BB%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">请求授权组件工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AuthorizationFilter%E9%BB%98%E8%AE%A4%E6%98%AF%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA"><span class="toc-number">1.1.1.</span> <span class="toc-text">AuthorizationFilter默认是最后一个</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E6%9C%89Dispatche%E9%83%BD%E6%98%AF%E6%8E%88%E6%9D%83%E7%9A%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">所有Dispatche都是授权的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Authencation%E6%9F%A5%E6%89%BE%E6%98%AF%E5%BB%B6%E8%BF%9F%E7%9A%84"><span class="toc-number">1.1.3.</span> <span class="toc-text">Authencation查找是延迟的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E7%AB%AF%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">授权端点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%8C%B9%E9%85%8D"><span class="toc-number">1.3.</span> <span class="toc-text">请求匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Ant%E8%BF%9B%E8%A1%8C%E5%8C%B9%E9%85%8D"><span class="toc-number">1.3.1.</span> <span class="toc-text">使用Ant进行匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8C%B9%E9%85%8D"><span class="toc-number">1.3.2.</span> <span class="toc-text">使用正则表达式进行匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8HTTP-Method%E8%BF%9B%E8%A1%8C%E5%8C%B9%E9%85%8D"><span class="toc-number">1.3.3.</span> <span class="toc-text">使用HTTP Method进行匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E5%88%86%E6%B4%BE%E5%99%A8-Dispatcher-%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D"><span class="toc-number">1.3.4.</span> <span class="toc-text">根据分派器(Dispatcher)类型匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%B9%E9%85%8D%E5%99%A8"><span class="toc-number">1.3.5.</span> <span class="toc-text">使用自定义匹配器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BARequest%E6%8E%88%E6%9D%83"><span class="toc-number">1.4.</span> <span class="toc-text">为Request授权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8E%88%E6%9D%83%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E7%AD%96%E7%95%A5%E4%BB%A3%E7%90%86%E6%88%96%E5%85%B6%E4%BB%96%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.5.</span> <span class="toc-text">使用授权数据库、策略代理或其他服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90permitAll%E8%80%8C%E9%9D%9E%E7%9A%84%E5%BF%BD%E8%A7%86"><span class="toc-number">1.6.</span> <span class="toc-text">推荐permitAll而非的忽视</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8-Security-%E5%8C%B9%E9%85%8D%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">安全(Security)匹配器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%BA%A7%E5%88%AB%E6%8E%88%E6%9D%83"><span class="toc-number">2.</span> <span class="toc-text">方法级别授权</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%BA%A7%E5%88%AB%E6%8E%88%E6%9D%83%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">方法级别授权工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E6%B3%A8%E8%A7%A3%E6%98%AF%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-number">2.1.1.</span> <span class="toc-text">多个注解是顺序执行的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E6%94%AF%E6%8C%81%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.1.2.</span> <span class="toc-text">不支持重复注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AA%E6%B3%A8%E8%A7%A3%E9%83%BD%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E5%88%87%E5%85%A5%E7%82%B9"><span class="toc-number">2.1.3.</span> <span class="toc-text">每个注解都有自己的切入点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AA%E6%B3%A8%E8%A7%A3%E9%83%BD%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">2.1.4.</span> <span class="toc-text">每个注解都有自己的方法拦截器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E6%8E%88%E4%BA%88%E6%9D%83%E9%99%90%E8%80%8C%E9%9D%9E%E4%BD%BF%E7%94%A8%E5%A4%8D%E6%9D%82%E7%9A%84SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.1.5.</span> <span class="toc-text">建议使用授予权限而非使用复杂的SpEL表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%AF%B7%E6%B1%82%E7%BA%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%BA%A7%E6%8E%88%E6%9D%83"><span class="toc-number">2.2.</span> <span class="toc-text">比较请求级和方法级授权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%BF%9B%E8%A1%8C%E6%8E%88%E6%9D%83"><span class="toc-number">2.3.</span> <span class="toc-text">使用注解进行授权</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-PreAuthorize%E6%8E%88%E6%9D%83%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">使用@PreAuthorize授权方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-PostAuthorize%E7%9A%84%E6%8E%88%E6%9D%83%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%9C"><span class="toc-number">2.3.2.</span> <span class="toc-text">使用@PostAuthorize的授权方法结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-PreFilter%E8%BF%87%E6%BB%A4%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0"><span class="toc-number">2.3.3.</span> <span class="toc-text">用@PreFilter过滤方法参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-PostFilter%E8%BF%87%E6%BB%A4%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%9C"><span class="toc-number">2.3.4.</span> <span class="toc-text">使用@PostFilter过滤方法结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Secured%E6%8E%88%E6%9D%83%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">2.3.5.</span> <span class="toc-text">使用@Secured授权方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8JSR-250%E6%B3%A8%E8%A7%A3%E6%8E%88%E6%9D%83%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">2.3.6.</span> <span class="toc-text">使用JSR-250注解授权方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%B1%BB%E6%88%96%E6%8E%A5%E5%8F%A3%E7%BA%A7%E5%88%AB%E5%A3%B0%E6%98%8E%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.3.7.</span> <span class="toc-text">在类或接口级别声明注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.3.8.</span> <span class="toc-text">使用元注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E7%94%A8%E7%89%B9%E5%AE%9A%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.3.9.</span> <span class="toc-text">启用特定注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%9B%E8%A1%8C%E6%8E%88%E6%9D%83"><span class="toc-number">2.4.</span> <span class="toc-text">使用进行授权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E6%8E%88%E6%9D%83%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">以编程方式授权方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-%E5%9C%A8SpEL%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89Bean"><span class="toc-number">2.5.1.</span> <span class="toc-text">方法一: 在SpEL中使用自定义Bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%AE%A1%E7%90%86%E5%99%A8-Authorization-Manager"><span class="toc-number">2.5.2.</span> <span class="toc-text">方法二: 使用自定义授权管理器(Authorization Manager)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A4%84%E7%90%86"><span class="toc-number">2.5.3.</span> <span class="toc-text">方法三: 自定义表达式处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8AspectJ%E8%BF%9B%E8%A1%8C%E6%8E%88%E6%9D%83"><span class="toc-number">2.6.</span> <span class="toc-text">使用AspectJ进行授权</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%87%E5%85%A5%E7%82%B9%E5%8C%B9%E9%85%8D%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.1.</span> <span class="toc-text">用自定义切入点匹配方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8EAspectJ-Byte-weaving"><span class="toc-number">2.6.2.</span> <span class="toc-text">与AspectJ Byte-weaving</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9AOrder"><span class="toc-number">2.7.</span> <span class="toc-text">指定Order</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8SpEL%E8%A1%A8%E8%BE%BE%E6%8E%88%E6%9D%83"><span class="toc-number">2.8.</span> <span class="toc-text">使用SpEL表达授权</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8E%88%E6%9D%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%97%E6%AE%B5%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">2.8.1.</span> <span class="toc-text">使用授权表达式字段和方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0"><span class="toc-number">2.9.</span> <span class="toc-text">使用方法参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%AE%89%E5%85%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-ACL"><span class="toc-number">3.</span> <span class="toc-text">域对象安全访问控制(ACL)</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/IT/Web/Angular%E5%AD%A6%E4%B9%A0/" title="Angular学习">Angular学习</a><time datetime="2023-09-04T03:28:37.000Z" title="发表于 2023-09-04 11:28:37">2023-09-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/IT/Spring%20Security/%E6%9E%B6%E6%9E%84/Spring%20Security%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81%E6%9E%B6%E6%9E%84/" title="Spring Security权限认证架构">Spring Security权限认证架构</a><time datetime="2023-06-29T08:55:03.000Z" title="发表于 2023-06-29 16:55:03">2023-06-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/IT/Spring%20Security/%E5%9F%BA%E4%BA%8EServlet%E7%9A%84Spring%20Security%20Authorization%E9%9B%86%E6%88%90/" title="基于Servlet的Spring Security Authorization集成">基于Servlet的Spring Security Authorization集成</a><time datetime="2023-06-29T08:29:25.000Z" title="发表于 2023-06-29 16:29:25">2023-06-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/IT/Spring%20Security/%E5%9F%BA%E4%BA%8EServlet%E7%9A%84Spring%20Security%20Authentication%E9%9B%86%E6%88%90/" title="基于Servlet的Spring Security Authentication集成">基于Servlet的Spring Security Authentication集成</a><time datetime="2023-06-26T08:29:25.000Z" title="发表于 2023-06-26 16:29:25">2023-06-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/IT/Spring%20Framework/Spring%20Boot/Spring%20Boot%E7%AE%80%E4%BB%8B/" title="Spring Boot简介">Spring Boot简介</a><time datetime="2023-06-16T09:56:01.950Z" title="发表于 2023-06-16 17:56:01">2023-06-16</time></div></div></div></div></div></div></main><footer id="footer" style="background: #13161e"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2023 By Dickens Hu</div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">鲁ICP备15029721号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>